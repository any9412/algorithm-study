삽입정렬

- 기존의 정렬된 배열에 새로운 원소를 삽입한다.

- 과정
  1. 두 번째 원소부터 시작하여 그 앞의 자료들과 값을 비교하여 삽입할 위치 선택.
     => 비교시 https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html에 의하면, 원소의 바로 앞에 위치한 자료부터 비교를 하는데 이는 삽입정렬의 기본 원칙인가, 아니면 저자가 정한 원칙인가?
        시간 복잡도 측면에서는 어떤 방향으로 비교해도 동일함.
  2. 마지막 원소까지 위 과정을 반복한다.

- 특징
  1. 선택정렬과 달리 안정성을 만족한다.
     Ex)
     Input: 3(1),3(2),2,1// 괄호 안의 숫자는 같은 레코드에서 순서를 의미
     1회차: 3(1),3(2),2,1 => 3(2)와 3(1)은 값이 동일하니 순서의 변경이 없다.
     2회차: 3(1), 2, 3(2), 1 -> 2, 3(1), 3(2), 1
     3회차: 2, 3(1), 1, 3(2) -> 2, 1, 3(1), 3(2) -> 1, 2, 3(1), 3(2)
  2. 간단한 구조
  3. 배열이 이미 정렬되어있는 경우에 유리함.
  4. 자료들의 이동이 많은 편
  5. 자료가 클 경우 적합하지 않음

- 시간 복잡도
  - 최선의 경우
    이미 정렬된 배열의 경우 원소의 비교만 진행하므로 (n-1) 번, O(n)
  - 최악의 경우
    배열이 역순으로 정렬된 경우
    - 비교 횟수
      외부 루프 안의 각 반복마다 i 번의 비교 수행.
      (n-1) + (n-2) + ... + 2 + 1 = n(n-1)/2 = O(n^2)
    - 교환 횟수
      외부 루프의 각 단계마다 (i+2) 번의 이동 발생
      n(n-1)/2 + 2(n-1) = (n^2 _ 3*n -4)/2 = O(n^2)
    - T(n) = o(n^2)

- 결과
  구현은 간단하나 비효율적이다. 이에 비해 퀵정렬, 힙정렬, 합병정렬,
  기수정렬은 효율적이라 할 수 있다.
