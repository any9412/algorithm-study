합병 정렬

- 존 폰 노이만이 제안한 방법.

- 안정 정렬에 속함.

- 분할 정복(Divdie and Conquer) 알고리증에 속함.
  - 분할 정복 : 문제를 작은 2개의 문제로 분리하여 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략.
  - 분활 정복 방법은 순환호출을 이용.

- Steps
  1. 리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.
  2. 정렬되지 않은 리스트를 절반으로 잘라(Divide and Conquer) 비슷한 크기의 두 부분 리스트로 나눈다.
    2-1. 리스트의 크기가 충분히 작지 않은 경우에는 다시 절반으로 나눈다.
  3. 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
  4. 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.

- 합병 단계 과정
  : 합병 단계는 최소의 크기(1)로 나뉘어진 배열이 combine되어 최종적으로 2개의 부분 리스트가 도출된 상태.
  Ex) 
     27 10 12 20 25 13 15 22
             ...
     10 12 20 21 | 13 15 22 25

  1. 두 배열의 첫번째 원소끼리 비교하며, 더 작은 수를 추가 리스트로 옮긴다.
  2. 하나의 배열이 끝날때까지 반복.
  3. 하나의 배열이 끝난 경우, 나머지 배열에 있는 숫자 전체를 추가 리스트에 옮긴다.
  4. 추가 리스트를 원 리스트로 옮긴다.

- 특징
  - 추가 리스트가 필요하다.
    => in-place sorting이 아니다.
  - 각 부분 배열을 정렬할 때도 합병 정렬을 순환적으로 호출하여 적용한다.(2-1)
  - 합병 정렬에서 실제로 정렬이 이루어지는 시점은 2개의 리스트를 합병(merge) 하는 단계이다.
  - 레코드의 크기가 큰 경우에는 이동 횟수가 많아 시간 낭비를 초래한다.
  - 안정적인 정렬 방법.
    => 데이터 분포에 영향을 덜 받는다. 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다. (O(nlog2n))
  - 레코드를 연결 리스트로 구성하면, 링크 인덱스만 변경되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다. 
    => in-placing sorting 가능.
    * 연결 리스트
      : 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조. 데이터를 담고 있는 노드들이 연결되어 있는데, 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하게 된다. 
	- 연결 리스트 종류
	  1. 단일 연결 리스트 : 다음 노드를 가리키는 포인터 하나만 갖고 있는 노드를 갖는 리스트.
	  2. 이중 연결 리스트 : 다음 노드와 이전 노드를 가리키는 포인터 2개를 갖고 있는 노드를 갖는 리스트.
	  3. 원형 연결 리스트 : 단일 연결 리스트 형태에서 마지막 노드가 처음 노드를 가리키는 형태로 원형을 만든 구조.


  - 크기가 큰 레코드를 정렬할 경우에 연결 리스트를 사용한다면, 합병 정렬은 퀵 정렬을 포함한 다른 어떤 정렬 방법보다 효율적이다.

- 시간 복잡도
  - 분할 단계: 비교 & 이동이 없음
  - 합병 단계
    - 비교 횟수
      - 순환 호출의 깊이 (합병 단계의 수)
        레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, n=2^3의 경우, 2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다. 이것을 일반화하면 n=2^k의 경우, k(k=log₂n)임을 알 수 있다.
        => k=log₂n
      - 각 합병 단계의 비교 연산
        크기 1인 부분 배열 2개를 합병하는 데는 최대 2번의 비교 연산이 필요하고, 부분 배열의 쌍이 4개이므로 24=8번의 비교 연산이 필요하다. 다음 단계에서는 크기 2인 부분 배열 2개를 합병하는 데 최대 4번의 비교 연산이 필요하고, 부분 배열의 쌍이 2개이므로 42=8번의 비교 연산이 필요하다. 마지막 단계에서는 크기 4인 부분 배열 2개를 합병하는 데는 최대 8번의 비교 연산이 필요하고, 부분 배열의 쌍이 1개이므로 8*1=8번의 비교 연산이 필요하다. 이것을 일반화하면 하나의 합병 단계에서는 최대 n번의 비교 연산을 수행함을 알 수 있다.
        => 최대 n번
      - 순환 호출의 깊이 만큼의 합병 단계 * 각 합병 단계의 비교 연산 = nlog₂n
    - 이동 횟수
      - 순환 호출의 깊이 (합병 단계의 수)
        => k=log₂n
      - 각 합병 단계의 이동 연산
        임시 배열에 복사했다가 다시 가져와야 되므로 이동 연산은 총 부분 배열에 들어 있는 요소의 개수가 n인 경우, 레코드의 이동이 2n번 발생한다.
      - 순환 호출의 깊이 만큼의 합병 단계 * 각 합병 단계의 이동 연산 = 2nlog₂n
  - T(n) = nlog₂n(비교) + 2nlog₂n(이동) = 3nlog₂n = O(nlog₂n)
